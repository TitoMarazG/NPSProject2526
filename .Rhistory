guides(color = "none") +
# Zoom in using coord_map to focus on the bounding box
coord_map("mercator", xlim = c(lon_min-1, lon_max+1), ylim = c(lat_min-1, lat_max+1)) +
# Animate based on time
transition_reveal(time_numeric)
# Create the animation
anim <- animate(p, fps = 5, duration = 7, width = 800, height = 600, nframes = 100)
View(data_wide)
View(p)
# Create the plot
p <- ggplot() +
# Add world map as the background
geom_polygon(data = world_map, aes(x = long, y = lat, group = group), fill = "lightgray", color = "white") +
# Add the dynamic buoy trajectories
geom_path(data = data_dynamic, aes(x = longitude, y = latitude, group = platformId, color = factor(platformId)),
linewidth = 1.2, alpha = 0.7) +
geom_point(data = data_dynamic, aes(x = longitude, y = latitude, color = factor(platformId)), size = 3) +
# Customize color scale for buoy trajectories
scale_color_viridis_d() +
# Add labels
labs(title = "Buoy Trajectories Over Time", x = "Longitude", y = "Latitude", color = "Buoy ID") +
# Apply theme and remove legend
theme_minimal() +
guides(color = "none") +
# Zoom in using coord_map to focus on the bounding box
coord_map("mercator", xlim = c(lon_min-1, lon_max+1), ylim = c(lat_min-1, lat_max+1)) +
# Animate based on time
transition_reveal(time_numeric)
# Create the animation
anim <- animate(p, fps = 5, duration = 7, width = 800, height = 600, nframes = 100)
# Ensure necessary libraries are loaded
library(ggplot2)
library(gganimate)
library(gifski)
library(dplyr)
library(tidyverse)
library(lubridate)
library(maps)  # For world map data
# Create the animation
anim <- animate(p, fps = 5, duration = 7, width = 800, height = 600, nframes = 100)
colnames(data_dynamic)
View(data_wide)
View(data_dynamic)
data_dynamic <- data_dynamic %>% arrange(platformId, date, time)  # Ensure ordered data
# Create the plot
# Crea la base del grafico
p <- ggplot(data_dynamic, aes(x = longitude, y = latitude, color = as.factor(platformId))) +
geom_path(aes(group = platformId), size = 1, alpha = 0.7) +  # Rappresenta la traiettoria
geom_point(aes(color = as.factor(platformId)), size = 2) +      # Aggiungi i punti della traiettoria
scale_color_viridis_d() +  # Colori per platformId
theme_minimal() +
labs(title = "Traiettoria delle boe", x = "Longitude", y = "Latitude") +
theme(legend.position = "none")
# Create the plot
# Crea la base del grafico
p <- ggplot(data_dynamic, aes(x = longitude, y = latitude, color = as.factor(platformId))) +
geom_path(aes(group = platformId), linewidth = 1, alpha = 0.7) +  # Rappresenta la traiettoria
geom_point(aes(color = as.factor(platformId)), linewidth = 2) +      # Aggiungi i punti della traiettoria
scale_color_viridis_d() +  # Colori per platformId
theme_minimal() +
labs(title = "Traiettoria delle boe", x = "Longitude", y = "Latitude") +
theme(legend.position = "none")
# Create the plot
# Crea la base del grafico
p <- ggplot(data_dynamic, aes(x = longitude, y = latitude, color = as.factor(platformId))) +
geom_path(aes(group = platformId), linewidth = 1, alpha = 0.7) +  # Rappresenta la traiettoria
geom_point(aes(color = as.factor(platformId)), linewidth = 2) +      # Aggiungi i punti della traiettoria
scale_color_viridis_d() +  # Colori per platformId
theme_minimal() +
labs(title = "Traiettoria delle boe", x = "Longitude", y = "Latitude") +
theme(legend.position = "none")
# Create the plot
# Crea la base del grafico
p <- ggplot(data_dynamic, aes(x = longitude, y = latitude, color = as.factor(platformId))) +
geom_path(aes(group = platformId), linewidth = 1, alpha = 0.7) +  # Rappresenta la traiettoria
geom_point(aes(color = as.factor(platformId)), size = 2) +      # Aggiungi i punti della traiettoria
scale_color_viridis_d() +  # Colori per platformId
theme_minimal() +
labs(title = "Traiettoria delle boe", x = "Longitude", y = "Latitude") +
theme(legend.position = "none")
# Crea l'animazione
anim <- p + transition_time(as.POSIXct(paste(data_dynamic$date, data_dynamic$time))) +  # Aggiungi la transizione temporale
labs(title = "Traiettoria delle boe nel tempo", subtitle = "Data: {frame_time}", x = "Longitude", y = "Latitude")
# Mostra l'animazione
anim
summary(data_dynamic$date)
summary(data_dynamic$time)
# Contare i NA per ogni colonna
colSums(is.na(data_dynamic))
# Verifica la presenza di NA nella colonna datetime
sum(is.na(data_dynamic$datetime))
# Verifica la presenza di NA nella colonna datetime
sum(is.na(data_dynamic$date))
# Verifica la presenza di NA nella colonna datetime
sum(is.na(data_dynamic$time))
# Unisci 'date' e 'time' in una nuova colonna 'datetime'
data_dynamic$datetime <- as.POSIXct(paste(data_dynamic$date, data_dynamic$time), format="%Y-%m-%d %H:%M:%S")
# Verifica la nuova colonna datetime
head(data_dynamic$datetime)
View(data_dynamic)
file_path <- "/ Users/leomarcellopoli/Documents/Applied/Project/data_wide.csv"
file_path <- "/Users/leomarcellopoli/Documents/Applied/Project/data_wide.csv"
data_wide <- read.csv(file_path, header = TRUE, stringsAsFactors = FALSE,sep = ",")
head(data_wide)
# Convert time to proper datetime format
# data_wide <- data_wide %>%
# mutate(
# datetime = ymd_hms(time),  # Convert to date-time
# date = as.integer(format(datetime, "%Y%m%d")),
# time_numeric = as.numeric(datetime)  # Convert time to numeric for animation
# ) %>%
data_wide <- data_wide %>% relocate(date, .after = platformId) # sposto la colonna date al secondo posto
View(data_wide)
data_wide <- data_wide %>% arrange(platformId, date, time)  # Ensure ordered data
View(data_wide)
# Remove static buoys (buoys where latitude and longitude do not change over time)
data_dynamic <- data_wide %>%
group_by(platformId) %>%
filter(n_distinct(latitude) > 1 | n_distinct(longitude) > 1) %>%
ungroup()
data_dynamic <- data_dynamic %>% arrange(platformId, date, time)  # Ensure ordered data
View(data_dynamic)
# Crea il grafico base
p <- ggplot(data_dynamic, aes(x = longitude, y = latitude, color = as.factor(platformId))) +
geom_path(aes(group = platformId), size = 1, alpha = 0.7) +  # Rappresenta la traiettoria
geom_point(aes(color = as.factor(platformId)), size = 2) +      # Aggiungi i punti della traiettoria
scale_color_viridis_d() +  # Colori per platformId
theme_minimal() +
labs(title = "Traiettoria delle boe", x = "Longitude", y = "Latitude") +
theme(legend.position = "none")
# Aggiungi l'animazione con 'transition_time', ma usa 'date' e 'time' come variabili separate
anim <- p + transition_time(as.POSIXct(paste(data_dynamic$date, data_dynamic$time), format="%Y%m%d %H%M%S")) +
labs(title = "Traiettoria delle boe nel tempo", subtitle = "Data: {frame_time}", x = "Longitude", y = "Latitude")
# Mostra l'animazione
anim
# Crea il grafico base
p <- ggplot(data_dynamic, aes(x = longitude, y = latitude, color = as.factor(platformId))) +
geom_path(aes(group = platformId), size = 1, alpha = 0.7) +  # Rappresenta la traiettoria
geom_point(aes(color = as.factor(platformId)), size = 2) +      # Aggiungi i punti della traiettoria
scale_color_viridis_d() +  # Colori per platformId
theme_minimal() +
labs(title = "Traiettoria delle boe", x = "Longitude", y = "Latitude") +
theme(legend.position = "none")
# Aggiungi l'animazione con 'transition_time', ma usa 'date' e 'time' come variabili separate
anim <- p + transition_time(as.POSIXct(paste(data_dynamic$date, data_dynamic$time), format="%Y%m%d %H%M")) +
labs(title = "Traiettoria delle boe nel tempo", subtitle = "Data: {frame_time}", x = "Longitude", y = "Latitude")
# Mostra l'animazione
anim
install.packages("ggmap")
library(ggmap)
# Get world map data
world_map <- get_map(location = "world", zoom = 1)
# Mostra l'animazione
anim
world_map
# Crea il grafico base
p <- ggmap(world_map) +
ggplot(data_dynamic, aes(x = longitude, y = latitude, color = as.factor(platformId))) +
geom_path(aes(group = platformId), size = 1, alpha = 0.7) +  # Rappresenta la traiettoria
geom_point(aes(color = as.factor(platformId)), size = 2) +      # Aggiungi i punti della traiettoria
scale_color_viridis_d() +  # Colori per platformId
theme_minimal() +
labs(title = "Traiettoria delle boe", x = "Longitude", y = "Latitude") +
theme(legend.position = "none")
# Get world map data
world_map <- get_map(location = "world", zoom = 1)
# Get world map data
world_map <- get_map(location = "world", zoom = 1)
# Get world map data
world_map <- map_data("world")
world_map
# Get world map data
world_map <- map_data("world")
world_map
# Crea il grafico base
p <- ggplot() +
# Add world map as the background
geom_polygon(data = world_map, aes(x = long, y = lat, group = group), fill = "lightgray", color = "white") +
geom_path(aes(group = platformId), linewidth = 1, alpha = 0.7) +  # Rappresenta la traiettoria
geom_point(aes(color = as.factor(platformId)), size = 2) +      # Aggiungi i punti della traiettoria
scale_color_viridis_d() +  # Colori per platformId
theme_minimal() +
labs(title = "Traiettoria delle boe", x = "Longitude", y = "Latitude") +
theme(legend.position = "none")
# Aggiungi l'animazione con 'transition_time', ma usa 'date' e 'time' come variabili separate
anim <- p + transition_time(as.POSIXct(paste(data_dynamic$date, data_dynamic$time), format="%Y%m%d %H%M")) +
labs(title = "Traiettoria delle boe nel tempo", subtitle = "Data: {frame_time}", x = "Longitude", y = "Latitude")
# Mostra l'animazione
anim
# Crea il grafico base
ggplot() +
# Add world map as the background
geom_polygon(data = world_map, aes(x = long, y = lat, group = group), fill = "lightgray", color = "white") +
geom_path(aes(group = platformId), linewidth = 1, alpha = 0.7) +  # Rappresenta la traiettoria
geom_point(aes(color = as.factor(platformId)), size = 2) +      # Aggiungi i punti della traiettoria
scale_color_viridis_d() +  # Colori per platformId
theme_minimal() +
labs(title = "Traiettoria delle boe", x = "Longitude", y = "Latitude") +
theme(legend.position = "none")
rlang::last_trace()
# TOPICS:
# Hierarchical clustering
# K-means clustering
# DBSCAN
# Exercises
# Multidimensional Scaling
options(rgl.printRglwidget = TRUE)
library(mvtnorm)
library(MVN)
library(rgl)
library(car)
library(dbscan)
library(cluster)
library(fields)
# Hierarchical Clustering ---------------------------------------------------------------------
## Example 1: iris dataset --------------------------------------------------------------------
# let's forget the labels (we perform a cluster analysis, not a discriminant one)
species.name <- iris[,5]
iris4        <- iris[,1:4]
pairs(iris4, pch=19)
# compute the dissimilarity matrix of the data
# we choose the Euclidean metric (and then we look at other metrics)
help(dist)
iris.e <- dist(iris4, method='euclidean')
image(1:150,1:150,as.matrix(iris.e), main='metrics: Euclidean', asp=1, xlab='i', ylab='j')
# with other metrics:
iris.m <- dist(iris4, method='manhattan')
iris.c <- dist(iris4, method='canberra')
par(mfrow=c(1,3))
image(1:150,1:150,as.matrix(iris.e), main='metrics: Euclidean', asp=1, xlab='i', ylab='j' )
image(1:150,1:150,as.matrix(iris.c), main='metrics: Canberra', asp=1, xlab='i', ylab='j' )
image(1:150,1:150,as.matrix(iris.m), main='metrics: Manhattan', asp=1, xlab='i', ylab='j' )
par(mfrow=c(1,1))
# actually, the data are never ordered according to (unknown) labels
misc <- sample(150)
iris4 <- iris4[misc,]
iris.e <- dist(iris4, method='euclidean')
iris.m <- dist(iris4, method='manhattan')
iris.c <- dist(iris4, method='canberra')
par(mfrow=c(1,3))
image(1:150,1:150,as.matrix(iris.e), main='metrics: Euclidean', asp=1, xlab='i', ylab='j' )
image(1:150,1:150,as.matrix(iris.c), main='metrics: Canberra', asp=1, xlab='i', ylab='j' )
image(1:150,1:150,as.matrix(iris.m), main='metrics: Manhattan', asp=1, xlab='i', ylab='j' )
par(mfrow=c(1,1))
par(mfrow=c(1,3))
image(1:150,1:150,as.matrix(iris.e), main='metrics: Euclidean', asp=1, xlab='i', ylab='j' )
image(1:150,1:150,as.matrix(iris.c), main='metrics: Canberra', asp=1, xlab='i', ylab='j' )
image(1:150,1:150,as.matrix(iris.m), main='metrics: Manhattan', asp=1, xlab='i', ylab='j' )
par(mfrow=c(1,1))
species.name <- iris[,5]
iris4        <- iris[,1:4]
pairs(iris4, pch=19)
# compute the dissimilarity matrix of the data
# we choose the Euclidean metric (and then we look at other metrics)
help(dist)
iris.e <- dist(iris4, method='euclidean')
image(1:150,1:150,as.matrix(iris.e), main='metrics: Euclidean', asp=1, xlab='i', ylab='j')
# with other metrics:
iris.m <- dist(iris4, method='manhattan')
iris.c <- dist(iris4, method='canberra')
par(mfrow=c(1,3))
image(1:150,1:150,as.matrix(iris.e), main='metrics: Euclidean', asp=1, xlab='i', ylab='j' )
image(1:150,1:150,as.matrix(iris.c), main='metrics: Canberra', asp=1, xlab='i', ylab='j' )
image(1:150,1:150,as.matrix(iris.m), main='metrics: Manhattan', asp=1, xlab='i', ylab='j' )
par(mfrow=c(1,1))
# actually, the data are never ordered according to (unknown) labels
misc <- sample(150)
iris4 <- iris4[misc,]
iris.e <- dist(iris4, method='euclidean')
iris.m <- dist(iris4, method='manhattan')
iris.c <- dist(iris4, method='canberra')
par(mfrow=c(1,3))
image(1:150,1:150,as.matrix(iris.e), main='metrics: Euclidean', asp=1, xlab='i', ylab='j' )
image(1:150,1:150,as.matrix(iris.c), main='metrics: Canberra', asp=1, xlab='i', ylab='j' )
image(1:150,1:150,as.matrix(iris.m), main='metrics: Manhattan', asp=1, xlab='i', ylab='j' )
par(mfrow=c(1,1))
# Command hclust()
help(hclust)
# Command hclust()
help(hclust)
# Command hclust()
help(hclust)
# Command hclust()
help(hclust)
iris.es <- hclust(iris.e, method='single')
iris.es <- hclust(iris.e, method='single')
iris.ea <- hclust(iris.e, method='average')
iris.ec <- hclust(iris.e, method='complete')
iris.ec <- hclust(iris.e, method='complete')
# if we want more detailed information on euclidean-complete
# clustering:
names(iris.ec)
iris.ec$merge  # order of aggregation of statistical units / clusters
iris.ec$height # distance at which we have aggregations
iris.ec$order  # ordering that allows to avoid intersections in the dendrogram
# plot of the dendrograms
par(mfrow=c(1,3))
plot(iris.es, main='euclidean-single', hang=-0.1, xlab='', labels=F, cex=0.6, sub='')
plot(iris.ec, main='euclidean-complete', hang=-0.1, xlab='', labels=F, cex=0.6, sub='')
plot(iris.ea, main='euclidean-average', hang=-0.1, xlab='', labels=F, cex=0.6, sub='')
par(mfrow=c(1,1))
rm(list=ls())
graphics.off()
library(corrplot)
library(lattice)
library(plot.matrix)
dataset <- read.csv("/Users/leomarcellopoli/Documents/Applied/Project/data_medione.csv")
View(dataset)
dataset <- read.csv("/Users/leomarcellopoli/Documents/Applied/Project/data_mediamese.csv")
dataset <- read.csv("/Users/leomarcellopoli/Documents/Applied/Project/dati_mediamese.csv")
View(dataset)
head(dataset)
dataset <- dataset[order(dataset$buoy_id, dataset$year, dataset$month)
dataset <- dataset[order(dataset$buoy_id, dataset$year, dataset$month)]
dataset <- dataset[order(dataset$buoy_id, dataset$year, dataset$month)]
dataset <- read.csv("/Users/leomarcellopoli/Documents/Applied/Project/dati_mediamese.csv")
dataset <- dataset[order(dataset$buoy_id, dataset$year, dataset$month)]
names(dataset)
dataset <- dataset[order(dataset$buoy_id, dataset$year, dataset$month)]
dataset <- dataset[, c(1, 3, 2, 4:ncol(df))]
dataset <- dataset[, c(1, 3, 2, 4:ncol(dataset))]
dataset <- dataset[, c(1, 3, 2, 4:ncol(dataset))]
dataset <- dataset[, c(1, 3, 2, 4:ncol(dataset))]
dataset <- dataset[order(dataset$buoy_id, dataset$year, dataset$month)]
dataset <- dataset[order(dataset$buoy_id, dataset$year, dataset$month)]
dataset <- dataset[order(dataset$buoy_id, dataset$year, dataset$month), ]
dataset <- read.csv("/Users/leomarcellopoli/Documents/Applied/Project/dati_mediamese.csv")
dataset <- dataset[order(dataset$buoy_id, dataset$year, dataset$month), ]
dataset <- dataset[order(dataset$buoy_id, dataset$year, dataset$month), ]
dataset$month_year <- paste(sprintf("%02d", dataset$month), dataset$year, sep = "-")
xy1 <- xyplot(temperature ~ month_year,
groups = buoy_id,
data = dataset,
type = "l", lty = 1)
update(xy1, xlab = "Time (in weeks)",
ylab = "Visual acuity",
grid = "h")
remove(month_year)
dataset$month_year <- NULL
dataset$month_year <- as.Date(paste(dataset$year, dataset$month, "01", sep = "-"))
xy1 <- xyplot(temperature ~ month_year,
groups = buoy_id,
data = dataset,
type = "l", lty = 1)
xy1 <- xyplot(temperature ~ month_year,
groups = buoy_id,
data = dataset,
type = "l", lty = 1)
xy1 <- xyplot(temperature ~ month_year,
groups = buoy_id,
data = dataset,
type = "l", lty = 1)
update(xy1, xlab = "Time (in months)",
ylab = "Temperature",
grid = "h")
# sample means across time and coordinates
flst <- list(dataset$month_year.f, dataset$lat.f, dataset$lon.f)
View(flst)
View(flst)
# sample means across time and coordinates
flst <- list(dataset$month_year.f, dataset$lat.f, dataset$lon.f)
mean <- tapply(armd$temperature, flst, FUN = mean)
# sample means across time and coordinates
flst <- list(dataset$month_year.f, dataset$lat.f, dataset$lon.f)
mean <- tapply(dataset$temperature, flst, FUN = mean)
tMn
# sample means across time and coordinates
flst <- list(dataset$month_year.f, dataset$lat.f, dataset$lon.f)
sample_mean <- tapply(dataset$temperature, flst, FUN = mean)
length(dataset$temperature)
length(dataset$month_year)
length(dataset$lat)
length(dataset$lon)
# sample means across time and coordinates
flst <- list(dataset$year)
sample_mean <- tapply(dataset$temperature, flst, FUN = mean)
sample_mean
## Box-plots for visual acuity by treatment and time
bw1 <- bwplot(temperature ~ year,
data = dataset)
xlims <- c("Base", "4\nwks", "12\nwks", "24\nwks", "52\nwks")
update(bw1, xlim = xlims, pch = "|")
xlims <- c("2017", "2018", "2019", "2020", "2021", "2022", "2023", "2024", "2025")
update(bw1, xlim = xlims, pch = "|")
## Box-plots for visual acuity by treatment and time
bw1 <- bwplot(temperature ~ year,
data = dataset)
xlims <- c("2017", "2018", "2019", "2020", "2021", "2022", "2023", "2024", "2025")
update(bw1, xlim = xlims, pch = "|")
## Box-plots for visual acuity by treatment and time
bw1 <- bwplot(temperature ~ year.f,
data = dataset)
xlims <- c("2017", "2018", "2019", "2020", "2021", "2022", "2023", "2024", "2025")
## Box-plots for visual acuity by treatment and time
bw1 <- bwplot(temperature ~ year,
data = dataset)
xlims <- levels(dataset$year)
update(bw1, xlim = xlims, pch = "|")
dataset$month_year <- as.Date(paste(dataset$year, dataset$month, "01", sep = "-"))
dataset$year <- factor(dataset$year)  # Assicurati che year sia un fattore
## Box-plots for visual acuity by treatment and time
bw1 <- bwplot(temperature ~ year,
data = dataset)
update(bw1, xlim = xlims, pch = "|")
## Box-plots for visual acuity by treatment and time
bw1 <- bwplot(temperature ~ year,
data = dataset)
bw1
# Leggi lo shapefile
# Attenzione!: il file da usare è quello .shp
# ci mette un po'
seas <- st_read("/Users/leomarcellopoli/Documents/Applied/Project/Script Marchesin/World_Seas_IHO_v3 copia/World_Seas_IHO_v3.shp")
library(sp)               ## Data management
library(lattice)          ## Data management
library(latticeExtra)
library(geoR)             ## Geostatistics
library(gstat)            ## Geostatistics
library(raster)           ## Per creare la griglia
library(sf)               ## Per le coste
library(rnaturalearth)    ##
library(dplyr)
# Leggi lo shapefile
# Attenzione!: il file da usare è quello .shp
# ci mette un po'
seas <- st_read("/Users/leomarcellopoli/Documents/Applied/Project/Script Marchesin/World_Seas_IHO_v3 copia/World_Seas_IHO_v3.shp")
z <- var
A <- [z -2, -0.5 z-3]
A <- c(z, -2, -0.5, z-3)
A <- matrix(c(z - 2, -0.5 * z - 3), nrow = 1)
A <- matrix(c(z -2, -0.5  z-3), nrow = 1)
las
confint(aov)
confint(aov)
setwd("~/Documents/Nonparametric/Project/NPSProject2526")
# Data cleaning - poverty_rate
poverty_rate = read.csv(file = "data/povertyRate.csv", header = T)
poverty_rate = poverty_rate[poverty_rate$geo != "European Union - 27 countries (from 2020)",]
View(poverty_rate)
# Data cleaning - poverty_rate
poverty_rate = read.csv(file = "data/povertyRate.csv", header = T)
poverty_rate = poverty_rate[,4:]
poverty_rate = poverty_rate[,-1:3]
poverty_rate = poverty_rate[,5:length(poverty_rate)]
View(poverty_rate)
poverty_rate = poverty_rate[,1:5]
View(poverty_rate)
unique(poverty_rate$sex)
unique(poverty_rate$age)
length(unique(poverty_rate$age))
# Calcolo delle frequenze per ogni età
frequenza_età <- table(poverty_rate$age)
print(frequenza_età)
View(poverty_rate)
poverty_total_total = poverty_rate[poverty_rate$age == 'Total',]
poverty_total_total = poverty_total_total[poverty_total_total$sex == 'Total']
View(poverty_total_total)
poverty_total_total = poverty_total_total[poverty_total_total$sex == 'Total',]
View(poverty_total_total)
View(poverty_total_total)
poverty_total_total = poverty_total_total[, 3:5]
View(poverty_total_total)
spr_expenditures = read.csv("data/sprExpenditures.csv", header = T)
View(spr_expenditures)
unique(spr_expenditures$spfunc)
unique(poverty_total_total$geo)
poverty_rate = poverty_rate[poverty_rate$geo != "European Union - 27 countries (from 2020)"]
poverty_rate = poverty_rate[poverty_rate$geo != "European Union - 27 countries (from 2020)",]
poverty_total_total = poverty_rate[poverty_rate$age == 'Total',]
poverty_total_total = poverty_total_total[poverty_total_total$sex == 'Total',]
poverty_total_total = poverty_total_total[, 3:5]
unique(poverty_total_total$geo)
unique(spr_expenditures$geo)
spr_expenditures = read.csv("data/sprExpenditures.csv", header = T)
spr_expenditures = spr_expenditures[spr_expenditures$geo != "Euro area – 20 countries (from 2023)",]
spr_expenditures = spr_expenditures[spr_expenditures$geo != "Euro area - 19 countries  (2015-2022)",]
spr_expenditures = spr_expenditures[spr_expenditures$geo != "European Union - 27 countries (2007-2013)",]
spr_expenditures = spr_expenditures[spr_expenditures$geo != "European Union - 27 countries (from 2020)",]
spr_expenditures = spr_expenditures[spr_expenditures$geo != "European Union - 28 countries (2013-2020)",]
spr_expenditures = spr_expenditures[spr_expenditures$geo != "Euro area - 12 countries (2001-2006)",]
spr_expenditures = spr_expenditures[spr_expenditures$geo != "Euro area - 18 countries (2014)",]
spr_expenditures = spr_expenditures[spr_expenditures$geo != "European Economic Area except Liechtenstein",]
spr_expenditures = spr_expenditures[spr_expenditures$geo != "European Free Trade Association except Liechtenstein",]
spr_expenditures = spr_expenditures[spr_expenditures$geo != "European Union - 15 countries (1995-2004)",]
spr_expenditures = read.csv("data/sprExpenditures.csv", header = T)
{
spr_expenditures = spr_expenditures[spr_expenditures$geo != "Euro area – 20 countries (from 2023)",]
spr_expenditures = spr_expenditures[spr_expenditures$geo != "Euro area - 19 countries  (2015-2022)",]
spr_expenditures = spr_expenditures[spr_expenditures$geo != "European Union - 27 countries (2007-2013)",]
spr_expenditures = spr_expenditures[spr_expenditures$geo != "European Union - 27 countries (from 2020)",]
spr_expenditures = spr_expenditures[spr_expenditures$geo != "European Union - 28 countries (2013-2020)",]
spr_expenditures = spr_expenditures[spr_expenditures$geo != "Euro area - 12 countries (2001-2006)",]
spr_expenditures = spr_expenditures[spr_expenditures$geo != "Euro area - 18 countries (2014)",]
spr_expenditures = spr_expenditures[spr_expenditures$geo != "European Economic Area except Liechtenstein",]
spr_expenditures = spr_expenditures[spr_expenditures$geo != "European Free Trade Association except Liechtenstein",]
spr_expenditures = spr_expenditures[spr_expenditures$geo != "European Union - 15 countries (1995-2004)",]
}
# pulizia colonne
spr_expenditures = spr_expenditures[,4:11]
unique(spr_expenditures$spfunc)
unique(spr_expenditures$spscheme)
spr_expenditures = spr_expenditures[,spr_expenditures$spscheme != "All scheme"]
spr_expenditures = spr_expenditures[, -c("spscheme")]
spr_expenditures$spscheme <- NULL
unique(spr_expenditures$spdep)
frequenza_spdep <- table(spr_expenditures$spdep)
print(frequenza_età)
print(frequenza_spdep)
spr_expenditures_bulgaria <- spr_expenditures[spr_expenditures$geo == "Bulgaria"]
spr_expenditures_bulgaria <- spr_expenditures[spr_expenditures$geo == "Bulgaria",]
View(spr_expenditures_bulgaria)
unique(spr)
unique(spr_expenditures_bulgaria$spdepm)
