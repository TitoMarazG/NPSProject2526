image(1:150,1:150,as.matrix(iris.e), main='metrics: Euclidean', asp=1, xlab='i', ylab='j')
# with other metrics:
iris.m <- dist(iris4, method='manhattan')
iris.c <- dist(iris4, method='canberra')
par(mfrow=c(1,3))
image(1:150,1:150,as.matrix(iris.e), main='metrics: Euclidean', asp=1, xlab='i', ylab='j' )
image(1:150,1:150,as.matrix(iris.c), main='metrics: Canberra', asp=1, xlab='i', ylab='j' )
image(1:150,1:150,as.matrix(iris.m), main='metrics: Manhattan', asp=1, xlab='i', ylab='j' )
par(mfrow=c(1,1))
# actually, the data are never ordered according to (unknown) labels
misc <- sample(150)
iris4 <- iris4[misc,]
iris.e <- dist(iris4, method='euclidean')
iris.m <- dist(iris4, method='manhattan')
iris.c <- dist(iris4, method='canberra')
par(mfrow=c(1,3))
image(1:150,1:150,as.matrix(iris.e), main='metrics: Euclidean', asp=1, xlab='i', ylab='j' )
image(1:150,1:150,as.matrix(iris.c), main='metrics: Canberra', asp=1, xlab='i', ylab='j' )
image(1:150,1:150,as.matrix(iris.m), main='metrics: Manhattan', asp=1, xlab='i', ylab='j' )
par(mfrow=c(1,1))
par(mfrow=c(1,3))
image(1:150,1:150,as.matrix(iris.e), main='metrics: Euclidean', asp=1, xlab='i', ylab='j' )
image(1:150,1:150,as.matrix(iris.c), main='metrics: Canberra', asp=1, xlab='i', ylab='j' )
image(1:150,1:150,as.matrix(iris.m), main='metrics: Manhattan', asp=1, xlab='i', ylab='j' )
par(mfrow=c(1,1))
species.name <- iris[,5]
iris4        <- iris[,1:4]
pairs(iris4, pch=19)
# compute the dissimilarity matrix of the data
# we choose the Euclidean metric (and then we look at other metrics)
help(dist)
iris.e <- dist(iris4, method='euclidean')
image(1:150,1:150,as.matrix(iris.e), main='metrics: Euclidean', asp=1, xlab='i', ylab='j')
# with other metrics:
iris.m <- dist(iris4, method='manhattan')
iris.c <- dist(iris4, method='canberra')
par(mfrow=c(1,3))
image(1:150,1:150,as.matrix(iris.e), main='metrics: Euclidean', asp=1, xlab='i', ylab='j' )
image(1:150,1:150,as.matrix(iris.c), main='metrics: Canberra', asp=1, xlab='i', ylab='j' )
image(1:150,1:150,as.matrix(iris.m), main='metrics: Manhattan', asp=1, xlab='i', ylab='j' )
par(mfrow=c(1,1))
# actually, the data are never ordered according to (unknown) labels
misc <- sample(150)
iris4 <- iris4[misc,]
iris.e <- dist(iris4, method='euclidean')
iris.m <- dist(iris4, method='manhattan')
iris.c <- dist(iris4, method='canberra')
par(mfrow=c(1,3))
image(1:150,1:150,as.matrix(iris.e), main='metrics: Euclidean', asp=1, xlab='i', ylab='j' )
image(1:150,1:150,as.matrix(iris.c), main='metrics: Canberra', asp=1, xlab='i', ylab='j' )
image(1:150,1:150,as.matrix(iris.m), main='metrics: Manhattan', asp=1, xlab='i', ylab='j' )
par(mfrow=c(1,1))
# Command hclust()
help(hclust)
# Command hclust()
help(hclust)
# Command hclust()
help(hclust)
# Command hclust()
help(hclust)
iris.es <- hclust(iris.e, method='single')
iris.es <- hclust(iris.e, method='single')
iris.ea <- hclust(iris.e, method='average')
iris.ec <- hclust(iris.e, method='complete')
iris.ec <- hclust(iris.e, method='complete')
# if we want more detailed information on euclidean-complete
# clustering:
names(iris.ec)
iris.ec$merge  # order of aggregation of statistical units / clusters
iris.ec$height # distance at which we have aggregations
iris.ec$order  # ordering that allows to avoid intersections in the dendrogram
# plot of the dendrograms
par(mfrow=c(1,3))
plot(iris.es, main='euclidean-single', hang=-0.1, xlab='', labels=F, cex=0.6, sub='')
plot(iris.ec, main='euclidean-complete', hang=-0.1, xlab='', labels=F, cex=0.6, sub='')
plot(iris.ea, main='euclidean-average', hang=-0.1, xlab='', labels=F, cex=0.6, sub='')
par(mfrow=c(1,1))
rm(list=ls())
graphics.off()
library(corrplot)
library(lattice)
library(plot.matrix)
dataset <- read.csv("/Users/leomarcellopoli/Documents/Applied/Project/data_medione.csv")
View(dataset)
dataset <- read.csv("/Users/leomarcellopoli/Documents/Applied/Project/data_mediamese.csv")
dataset <- read.csv("/Users/leomarcellopoli/Documents/Applied/Project/dati_mediamese.csv")
View(dataset)
head(dataset)
dataset <- dataset[order(dataset$buoy_id, dataset$year, dataset$month)
dataset <- dataset[order(dataset$buoy_id, dataset$year, dataset$month)]
dataset <- dataset[order(dataset$buoy_id, dataset$year, dataset$month)]
dataset <- read.csv("/Users/leomarcellopoli/Documents/Applied/Project/dati_mediamese.csv")
dataset <- dataset[order(dataset$buoy_id, dataset$year, dataset$month)]
names(dataset)
dataset <- dataset[order(dataset$buoy_id, dataset$year, dataset$month)]
dataset <- dataset[, c(1, 3, 2, 4:ncol(df))]
dataset <- dataset[, c(1, 3, 2, 4:ncol(dataset))]
dataset <- dataset[, c(1, 3, 2, 4:ncol(dataset))]
dataset <- dataset[, c(1, 3, 2, 4:ncol(dataset))]
dataset <- dataset[order(dataset$buoy_id, dataset$year, dataset$month)]
dataset <- dataset[order(dataset$buoy_id, dataset$year, dataset$month)]
dataset <- dataset[order(dataset$buoy_id, dataset$year, dataset$month), ]
dataset <- read.csv("/Users/leomarcellopoli/Documents/Applied/Project/dati_mediamese.csv")
dataset <- dataset[order(dataset$buoy_id, dataset$year, dataset$month), ]
dataset <- dataset[order(dataset$buoy_id, dataset$year, dataset$month), ]
dataset$month_year <- paste(sprintf("%02d", dataset$month), dataset$year, sep = "-")
xy1 <- xyplot(temperature ~ month_year,
groups = buoy_id,
data = dataset,
type = "l", lty = 1)
update(xy1, xlab = "Time (in weeks)",
ylab = "Visual acuity",
grid = "h")
remove(month_year)
dataset$month_year <- NULL
dataset$month_year <- as.Date(paste(dataset$year, dataset$month, "01", sep = "-"))
xy1 <- xyplot(temperature ~ month_year,
groups = buoy_id,
data = dataset,
type = "l", lty = 1)
xy1 <- xyplot(temperature ~ month_year,
groups = buoy_id,
data = dataset,
type = "l", lty = 1)
xy1 <- xyplot(temperature ~ month_year,
groups = buoy_id,
data = dataset,
type = "l", lty = 1)
update(xy1, xlab = "Time (in months)",
ylab = "Temperature",
grid = "h")
# sample means across time and coordinates
flst <- list(dataset$month_year.f, dataset$lat.f, dataset$lon.f)
View(flst)
View(flst)
# sample means across time and coordinates
flst <- list(dataset$month_year.f, dataset$lat.f, dataset$lon.f)
mean <- tapply(armd$temperature, flst, FUN = mean)
# sample means across time and coordinates
flst <- list(dataset$month_year.f, dataset$lat.f, dataset$lon.f)
mean <- tapply(dataset$temperature, flst, FUN = mean)
tMn
# sample means across time and coordinates
flst <- list(dataset$month_year.f, dataset$lat.f, dataset$lon.f)
sample_mean <- tapply(dataset$temperature, flst, FUN = mean)
length(dataset$temperature)
length(dataset$month_year)
length(dataset$lat)
length(dataset$lon)
# sample means across time and coordinates
flst <- list(dataset$year)
sample_mean <- tapply(dataset$temperature, flst, FUN = mean)
sample_mean
## Box-plots for visual acuity by treatment and time
bw1 <- bwplot(temperature ~ year,
data = dataset)
xlims <- c("Base", "4\nwks", "12\nwks", "24\nwks", "52\nwks")
update(bw1, xlim = xlims, pch = "|")
xlims <- c("2017", "2018", "2019", "2020", "2021", "2022", "2023", "2024", "2025")
update(bw1, xlim = xlims, pch = "|")
## Box-plots for visual acuity by treatment and time
bw1 <- bwplot(temperature ~ year,
data = dataset)
xlims <- c("2017", "2018", "2019", "2020", "2021", "2022", "2023", "2024", "2025")
update(bw1, xlim = xlims, pch = "|")
## Box-plots for visual acuity by treatment and time
bw1 <- bwplot(temperature ~ year.f,
data = dataset)
xlims <- c("2017", "2018", "2019", "2020", "2021", "2022", "2023", "2024", "2025")
## Box-plots for visual acuity by treatment and time
bw1 <- bwplot(temperature ~ year,
data = dataset)
xlims <- levels(dataset$year)
update(bw1, xlim = xlims, pch = "|")
dataset$month_year <- as.Date(paste(dataset$year, dataset$month, "01", sep = "-"))
dataset$year <- factor(dataset$year)  # Assicurati che year sia un fattore
## Box-plots for visual acuity by treatment and time
bw1 <- bwplot(temperature ~ year,
data = dataset)
update(bw1, xlim = xlims, pch = "|")
## Box-plots for visual acuity by treatment and time
bw1 <- bwplot(temperature ~ year,
data = dataset)
bw1
# Leggi lo shapefile
# Attenzione!: il file da usare è quello .shp
# ci mette un po'
seas <- st_read("/Users/leomarcellopoli/Documents/Applied/Project/Script Marchesin/World_Seas_IHO_v3 copia/World_Seas_IHO_v3.shp")
library(sp)               ## Data management
library(lattice)          ## Data management
library(latticeExtra)
library(geoR)             ## Geostatistics
library(gstat)            ## Geostatistics
library(raster)           ## Per creare la griglia
library(sf)               ## Per le coste
library(rnaturalearth)    ##
library(dplyr)
# Leggi lo shapefile
# Attenzione!: il file da usare è quello .shp
# ci mette un po'
seas <- st_read("/Users/leomarcellopoli/Documents/Applied/Project/Script Marchesin/World_Seas_IHO_v3 copia/World_Seas_IHO_v3.shp")
z <- var
A <- [z -2, -0.5 z-3]
A <- c(z, -2, -0.5, z-3)
A <- matrix(c(z - 2, -0.5 * z - 3), nrow = 1)
A <- matrix(c(z -2, -0.5  z-3), nrow = 1)
las
confint(aov)
confint(aov)
setwd("~/Documents/Nonparametric/Project/NPSProject2526")
rm(list = ls())
graphics.off()
# Data cleaning
data_expediture_0 = read.csv(file = "data/spr_exp_type$defaultview_linear_2_0.csv", header = T)
head(data_expediture_0)
View(data_expediture_0)
dim(data_expediture_0)
View(data_expediture_0)
#selection of rows of Social protection benefits
unique(data_expediture_0$Main.expenditure.type)
View(data_expediture_0)
data_expediture_0 <- data_expediture_0[data_expediture_0$Main.expenditure.type == "Social protection benefits", ]
unique(data_expediture_0$Unit.of.measure)
data_expediture_0 <- data_expediture_0[data_expediture_0$Unit.of.measure == "Euro per inhabitant (at constant 2015 prices)", ]
# column selection
data_expediture_1 <- data_expediture_0[, 11:14]
data_expediture_1 <- data_expediture_1[, -3]
data_expediture_1 = data_expediture_1[data_expediture_1$Geopolitical.entity..reporting. != "Euro area – 20 countries (from 2023)",]
data_expediture_1 = data_expediture_1[data_expediture_1$Geopolitical.entity..reporting. != "Euro area - 19 countries  (2015-2022)",]
data_expediture_1 = data_expediture_1[data_expediture_1$Geopolitical.entity..reporting. != "European Union - 27 countries (2007-2013)",]
data_expediture_1 = data_expediture_1[data_expediture_1$Geopolitical.entity..reporting. != "European Union - 27 countries (from 2020)",]
data_expediture_1 = data_expediture_1[data_expediture_1$Geopolitical.entity..reporting. != "European Union - 28 countries (2013-2020)",]
# Data exploration
head(data_expediture_1)
View(data_expediture_1)
dim(data_expediture_1)
table(data_expediture_1$Geopolitical.entity..reporting.)
summary(data_expediture_1)
plot(data_expediture_1$TIME_PERIOD, data_expediture_1$OBS_VALUE)
# install.packages("ggplot2")
# install.packages("viridis") # Per la palette
library(ggplot2)
library(viridis)
# install.packages("ggplot2")
install.packages("viridis") # Per la palette
# install.packages("ggplot2")
# install.packages("viridis") # Per la palette
library(ggplot2)
library(viridis)
# install.packages("ggplot2")
install.packages("viridislite") # Per la palette
library(ggplot2)
library(viridis)
paese <- data_expediture_1$Geopolitical.entity..reporting.
ggplot(data = data_expediture_1,
aes(x = TIME_PERIOD, y = OBS_VALUE, color = paese, group = paese)) +
geom_line(linewidth = 1.5) +  # <- Linee Grosse (linewidth > 1)
scale_color_viridis(discrete = TRUE, option = "D") + # <- Palette Variata
geom_point(size = 3) + # Punti più grandi per abbinare le linee
labs(
title = "Social Protection Benefits per Paese nel Tempo",
x = "Periodo di Tempo",
y = "Social Protection Benefits"
)
library(dplyr)
library(ggrepel)
# install.packages("ggplot2")
# install.packages("viridislite") # Per la palette
# install.packages("ggrepel") # per le etichette
library(ggplot2)
library(viridis)
library(dplyr)
library(ggrepel)
# install.packages("ggplot2")
# install.packages("viridislite") # Per la palette
install.packages("ggrepel") # per le etichette
library(ggrepel)
# creo le etichette
data_labels <- data_expediture_1 %>%
group_by(paese) %>%
# Trova la riga con il TIME_PERIOD più recente per ogni paese
slice_max(order_by = TIME_PERIOD, n = 1) %>%
ungroup()
paese <- data_expediture_1$Geopolitical.entity..reporting.
# creo le etichette
data_labels <- data_expediture_1 %>%
group_by(paese) %>%
# Trova la riga con il TIME_PERIOD più recente per ogni paese
slice_max(order_by = TIME_PERIOD, n = 1) %>%
ungroup()
# creo le etichette
data_labels <- data_expediture_1 %>%
group_by(Geopolitical.entity..reporting.) %>%
# Trova la riga con il TIME_PERIOD più recente per ogni paese
slice_max(order_by = TIME_PERIOD, n = 1) %>%
ungroup()
ggplot(data = data_expediture_1,
aes(x = TIME_PERIOD, y = OBS_VALUE, color = paese, group = paese)) +
geom_line(linewidth = 1.5) +  # <- Linee Grosse (linewidth > 1)
scale_color_viridis(discrete = TRUE, option = "D") + # <- Palette Variata
geom_point(size = 3) + # Punti più grandi per abbinare le linee
labs(
title = "Social Protection Benefits per Paese nel Tempo",
x = "Periodo di Tempo",
y = "Social Protection Benefits"
)
#grafico con le etichette
ggplot(data = data_expediture_1,
aes(x = TIME_PERIOD, y = OBS_VALUE, color = paese, group = paese)) +
geom_line(linewidth = 1.5) +
scale_color_viridis(discrete = TRUE, option = "D") +
geom_point(size = 3) +
# --- INIZIO MODIFICHE ---
# 1. Aggiungi le etichette "intelligenti" alla fine delle linee
geom_text_repel(
data = data_labels, # Usa i dati che abbiamo filtrato
aes(label = paese), # L'etichetta è il nome del paese
size = 3.5,
fontface = "bold",
nudge_x = 0.2,       # Sposta le etichette leggermente a destra
direction = "y",     # Permetti di spostarle solo in verticale
hjust = 0,           # Allinea il testo a sinistra
segment.color = "grey50" # Colore della lineetta di collegamento
) +
# 2. Fai spazio a destra per le etichette
# Aumenta l'espansione del 15% sul lato destro (mult = c(0.05, 0.15))
scale_x_continuous(expand = expansion(mult = c(0.05, 0.15))) +
# 3. Rimuovi la legenda
theme(legend.position = "none") +
# --- FINE MODIFICHE ---
labs(
title = "Social Protection Benefits per Paese nel Tempo",
x = "Periodo di Tempo",
y = "Social Protection Benefits"
)
#grafico con le etichette
ggplot(data = data_expediture_1,
aes(x = TIME_PERIOD, y = OBS_VALUE, color = paese, group = paese)) +
geom_line(linewidth = 1.5) +
scale_color_viridis(discrete = TRUE, option = "D") +
geom_point(size = 3) +
# --- INIZIO MODIFICHE ---
# 1. Aggiungi le etichette "intelligenti" alla fine delle linee
geom_text_repel(
data = data_labels, # Usa i dati che abbiamo filtrato
aes(label = paese), # L'etichetta è il nome del paese
size = 3.5,
fontface = "bold",
nudge_x = 0.2,       # Sposta le etichette leggermente a destra
direction = "y",     # Permetti di spostarle solo in verticale
hjust = 0,           # Allinea il testo a sinistra
segment.color = "grey50" # Colore della lineetta di collegamento
) +
# 2. Fai spazio a destra per le etichette
# Aumenta l'espansione del 15% sul lato destro (mult = c(0.05, 0.15))
scale_x_continuous(expand = expansion(mult = c(0.05, 0.15))) +
# 3. Rimuovi la legenda
theme(legend.position = "none") +
# --- FINE MODIFICHE ---
labs(
title = "Social Protection Benefits per Paese nel Tempo",
x = "Periodo di Tempo",
y = "Social Protection Benefits"
)
#grafico con le etichette
ggplot(data = data_expediture_1,
aes(x = TIME_PERIOD, y = OBS_VALUE, color = paese, group = paese)) +
geom_line(linewidth = 1.5) +
scale_color_viridis(discrete = TRUE, option = "D") +
geom_point(size = 3) +
# --- INIZIO MODIFICHE ---
# 1. Aggiungi le etichette "intelligenti" alla fine delle linee
geom_text_repel(
data = data_labels, # Usa i dati che abbiamo filtrato
aes(label = Geopolitical.entity..reporting.), # L'etichetta è il nome del paese
size = 3.5,
fontface = "bold",
nudge_x = 0.2,       # Sposta le etichette leggermente a destra
direction = "y",     # Permetti di spostarle solo in verticale
hjust = 0,           # Allinea il testo a sinistra
segment.color = "grey50" # Colore della lineetta di collegamento
) +
# 2. Fai spazio a destra per le etichette
# Aumenta l'espansione del 15% sul lato destro (mult = c(0.05, 0.15))
scale_x_continuous(expand = expansion(mult = c(0.05, 0.15))) +
# 3. Rimuovi la legenda
theme(legend.position = "none") +
# --- FINE MODIFICHE ---
labs(
title = "Social Protection Benefits per Paese nel Tempo",
x = "Periodo di Tempo",
y = "Social Protection Benefits"
)
paese <- data_expediture_1$Geopolitical.entity..reporting.
# creo le etichette
data_labels <- data_expediture_1 %>%
group_by(Geopolitical.entity..reporting.) %>%
# Trova la riga con il TIME_PERIOD più recente per ogni paese
slice_max(order_by = TIME_PERIOD, n = 1) %>%
ungroup()
#grafico con legenda
ggplot(data = data_expediture_1,
aes(x = TIME_PERIOD, y = OBS_VALUE, color = paese, group = paese)) +
geom_line(linewidth = 1.5) +  # <- Linee Grosse (linewidth > 1)
scale_color_viridis(discrete = TRUE, option = "D") + # <- Palette Variata
geom_point(size = 3) + # Punti più grandi per abbinare le linee
labs(
title = "Social Protection Benefits per Paese nel Tempo",
x = "Periodo di Tempo",
y = "Social Protection Benefits"
)
#grafico con le etichette
ggplot(data = data_expediture_1,
aes(x = TIME_PERIOD, y = OBS_VALUE, color = Geopolitical.entity..reporting., group = Geopolitical.entity..reporting.)) +
geom_line(linewidth = 1.5) +
scale_color_viridis(discrete = TRUE, option = "D") +
geom_point(size = 3) +
# --- INIZIO MODIFICHE ---
# 1. Aggiungi le etichette "intelligenti" alla fine delle linee
geom_text_repel(
data = data_labels, # Usa i dati che abbiamo filtrato
aes(label = Geopolitical.entity..reporting.), # L'etichetta è il nome del paese
size = 3.5,
fontface = "bold",
nudge_x = 0.2,       # Sposta le etichette leggermente a destra
direction = "y",     # Permetti di spostarle solo in verticale
hjust = 0,           # Allinea il testo a sinistra
segment.color = "grey50" # Colore della lineetta di collegamento
) +
# 2. Fai spazio a destra per le etichette
# Aumenta l'espansione del 15% sul lato destro (mult = c(0.05, 0.15))
scale_x_continuous(expand = expansion(mult = c(0.05, 0.15))) +
# 3. Rimuovi la legenda
theme(legend.position = "none") +
# --- FINE MODIFICHE ---
labs(
title = "Social Protection Benefits per Paese nel Tempo",
x = "Periodo di Tempo",
y = "Social Protection Benefits"
)
# Definisci i paesi da includere
paesi_selezionati <- c("France", "Italy", "Germany", "Bulgaria", "Poland")
data_subsample <- data_expediture_1 %>%
# PASSO 1: Filtra il dataframe
filter( data_expediture_1$Geopolitical.entity..reporting. %in% paesi_selezionati)
paese <- data_subsample$Geopolitical.entity..reporting.
# PASSO 2: Crea il grafico con i dati filtrati
ggplot( data = data_subsample,
aes(x = TIME_PERIOD, y = OBS_VALUE, color = paese, group = paese)) +
geom_line(linewidth = 1.5) + # Linee grosse
geom_point(size = 3) +
scale_color_viridis(discrete = TRUE, option = "D") +
labs(
title = "Social Protection Benefits:",
x = "Periodo di Tempo",
y = "Social Protection Benefits"
)
# creo le etichette
data_labels_selezionati <- data_subsample %>%
group_by(Geopolitical.entity..reporting.) %>%
# Trova la riga con il TIME_PERIOD più recente per ogni paese
slice_max(order_by = TIME_PERIOD, n = 1) %>%
ungroup()
# creo le etichette
data_labels_selezionati <- data_subsample %>%
group_by(Geopolitical.entity..reporting.) %>%
# Trova la riga con il TIME_PERIOD più recente per ogni paese
slice_max(order_by = TIME_PERIOD, n = 1) %>%
ungroup()
#plot
ggplot( data = data_subsample,
aes(x = TIME_PERIOD, y = OBS_VALUE, color = Geopolitical.entity..reporting., group = Geopolitical.entity..reporting.)) +
geom_line(linewidth = 1.5) + # Linee grosse
geom_point(size = 3) +
scale_color_viridis(discrete = TRUE, option = "D") +
# --- INIZIO MODIFICHE ---
# 1. Aggiungi le etichette "intelligenti" alla fine delle linee
geom_text_repel(
data = data_labels_selezionati, # Usa i dati che abbiamo filtrato
aes(label = Geopolitical.entity..reporting.), # L'etichetta è il nome del paese
size = 3.5,
fontface = "bold",
nudge_x = 0.2,       # Sposta le etichette leggermente a destra
direction = "y",     # Permetti di spostarle solo in verticale
hjust = 0,           # Allinea il testo a sinistra
segment.color = "grey50" # Colore della lineetta di collegamento
) +
# 2. Fai spazio a destra per le etichette
# Aumenta l'espansione del 15% sul lato destro (mult = c(0.05, 0.15))
scale_x_continuous(expand = expansion(mult = c(0.05, 0.15))) +
# 3. Rimuovi la legenda
theme(legend.position = "none") +
# --- FINE MODIFICHE ---
labs(
title = "Social Protection Benefits:",
x = "Periodo di Tempo",
y = "Social Protection Benefits"
)
library(dplyr)
# Trova la colonna con il vecchio nome e assegnale il nuovo nome
names(data_expediture_1)[names(data_expediture_1) == "OBS_VALUE"] <- "SOCIAL_EXP"
poverty_rate <- read.csv(file = "data/poverty_rate_cleaned.csv", header = T)
View(poverty_rate)
names(poverty_rate)[names(poverty_rate) == "OBS_VALUE"] <- "POVERTY_RATE"
# Il dataset 'dati' viene modificato direttamente in questo caso
dataset_merged <- left_join(
x = data_expediture_1,      # Il dataset principale (left/sinistro)
y = poverty_rate,  # Il dataset da cui prendere le nuove colonne (right/destro)
# Specifica le colonne (chiavi) su cui basare l'unione
by = c("Geopolitical.entity..reporting.", "TIME_PERIOD")
)
head(dataset_merged)
