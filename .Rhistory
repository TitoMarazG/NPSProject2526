derivata_alternativa_fd <- D(data.fourier) # 1 indica la prima derivata
# Controlla se ci sono NA
sum(is.na(data))
# Se ce ne sono, usa na.omit() sul tuo dataframe/matrice 'data'
data_pulito <- na.omit(as.matrix(data))
time_pulito <- 1:dim(data_pulito)[1]
# Riprova il Data2fd() con i dati puliti:
data.fourier <- Data2fd(y = data_pulito, argvals = time_pulito, basisobj = basis_fourier)
# La funzione che esegue il fit della derivata
derivata_fourier_fd <- deriv.fd(
fdobj  = data.fourier,
nderiv = 1         # 1 indica la prima derivata
)
setwd("~/uni/2025-2026/non param/progetto/param/progetto/NPSProject2526")
rm(list = ls())
graphics.off()
data0 <- read.csv(file = "data/dataset_merged.csv", header = T)
library(tidyr)
library(dplyr) # Utile per la manipolazione generale
# Supponiamo che il tuo dataset si chiami 'dati_originali'
data <- data0 %>%
pivot_wider(
# La colonna che identifica le righe nel nuovo dataset
id_cols = Geopolitical.entity..reporting.,
# La colonna i cui valori (es. 2020, 2021) diventeranno i nomi delle nuove colonne
names_from = TIME_PERIOD,
# La colonna i cui valori (es. 3.4, 5.1) riempiranno le nuove colonne
values_from = POVERTY_RATE
)
data <- na.omit(data)
data <- t(data)
# Visualizza l'inizio del nuovo dataset
head(data)
str(data)
data <- data[-1, ]
nr <- nrow(data)
nc <- ncol(data)
data <- matrix(as.numeric(data),
nrow = nr, ncol = nc)
data <- na.omit(data)
data <- as.matrix(data)
# matplot
par(mfrow = c(1,1))
matplot(data, type = 'l', lty = 1, lwd = 1.5,
main = 'Povrty Rate', xlab = 'year', ylab = 'Poverty rate')
#Calcolare la media di ogni colonna (misurazione media)
mean_curve <- rowMeans(data)
par(mfrow = c(1,1))
matplot(data, type = 'l', col = rgb(0.6, 0, 0.6, 0.2), lty = 1, lwd = 1.5,
main = 'Povrty Rate', xlab = 'year', ylab = 'Poverty rate')
# Sovrapporre la curva media con un colore più acceso e una linea più spessa
lines(mean_curve, col = "darkviolet", lwd = 3)
# BSPLINE -----------------------------------------------------------------
library(car)
# for lasso regression
library(glmnet)
# functional DataAna
library(fda)
norder <- 4        # spline order (4th order polynomials)
degree <- norder-1  # spline degree
nbasis <- 5   # how many basis we want
time <- 1:dim(data)[1]
basis_spline <- create.bspline.basis(rangeval=range(time),
nbasis=nbasis,
norder=norder)
#### PLOT DELLA BASE SPLINES
par(mfrow=c(1,1))
plot(basis_spline)
data.bspline <- Data2fd(y = data, argvals = time,basisobj = basis_spline)
#### PLOT APPROX SPLINES
# x11()
par(mfrow=c(1,2))
plot.fd(data.bspline, main = 'spline approx: degree=3, nbasis=20')
matplot(data,type='l', main = 'true curves'  )
#### FOURIER ####
nbasis <- 6
basis_fourier <- create.fourier.basis(rangeval=range(time),nbasis=nbasis)
#### PLOT BASE FOURIER
par(mfrow=c(1,1))
plot(basis_fourier)
data.fourier <- Data2fd(y = as.matrix(data),argvals = time,basisobj = basis_fourier)
#### PLOT APROX FOURIER
# x11()
par(mfrow=c(1,2))
plot.fd(data.fourier, main = 'fourier approx: nbasis=10')
matplot(data,type='l', main = 'true curves'  )
rm(list = ls())
graphics.off()
data0 <- read.csv(file = "data/dataset_merged.csv", header = T)
library(tidyr)
View(data0)
rm(list = ls())
graphics.off()
data0 <- read.csv(file = "data/dataset_merged.csv", header = T)
library(tidyr)
library(dplyr) # Utile per la manipolazione generale
# Supponiamo che il tuo dataset si chiami 'dati_originali'
data <- data0 %>%
pivot_wider(
# La colonna che identifica le righe nel nuovo dataset
id_cols = Geopolitical.entity..reporting.,
# La colonna i cui valori (es. 2020, 2021) diventeranno i nomi delle nuove colonne
names_from = TIME_PERIOD,
# La colonna i cui valori (es. 3.4, 5.1) riempiranno le nuove colonne
values_from = c(POVERTY_RATE, SOCIAL_EXP)
)
data <- na.omit(data)
data <- t(data)
data <- na.omit(data)
View(data)
data <- t(data)
# Visualizza l'inizio del nuovo dataset
head(data)
View(data)
View(data0)
View(data)
data <- t(data)
View(data)
rm(list = ls())
graphics.off()
data0 <- read.csv(file = "data/dataset_merged.csv", header = T)
View(data0)
library(tidyr)
library(dplyr) # Utile per la manipolazione generale
# Supponiamo che il tuo dataset si chiami 'dati_originali'
data <- data0 %>%
pivot_wider(
# La colonna che identifica le righe nel nuovo dataset
id_cols = Geopolitical.entity..reporting.,
# La colonna i cui valori (es. 2020, 2021) diventeranno i nomi delle nuove colonne
names_from = TIME_PERIOD,
# La colonna i cui valori (es. 3.4, 5.1) riempiranno le nuove colonne
values_from = c(POVERTY_RATE, SOCIAL_EXP)
)
data <- na.omit(data)
View(data)
# 1. Ottieni tutti i nomi delle colonne
nomi_colonne <- names(data)
# 2. Identifica la colonna ID e le colonne da ordinare (escludi l'ID)
colonna_id <- "Geopolitical.entity..reporting."
colonne_da_ordinare <- setdiff(nomi_colonne, colonna_id)
# 3. Ordina le colonne per nome (alfabeticamente)
colonne_ordinate <- sort(colonne_da_ordinare)
# 4. Crea il nuovo ordine, mettendo l'ID per primo
nuovo_ordine <- c(colonna_id, colonne_ordinate)
# 5. Applica il nuovo ordine al dataset
data_ordinato <- data %>%
select(all_of(nuovo_ordine))
head(data_ordinato)
data <- t(data)
data <- t(data)
View(data)
rm(list = ls())
graphics.off()
data0 <- read.csv(file = "data/dataset_merged.csv", header = T)
library(tidyr)
library(dplyr) # Utile per la manipolazione generale
# Supponiamo che il tuo dataset si chiami 'dati_originali'
data <- data0 %>%
pivot_wider(
# La colonna che identifica le righe nel nuovo dataset
id_cols = Geopolitical.entity..reporting.,
# La colonna i cui valori (es. 2020, 2021) diventeranno i nomi delle nuove colonne
names_from = TIME_PERIOD,
# La colonna i cui valori (es. 3.4, 5.1) riempiranno le nuove colonne
values_from = c(POVERTY_RATE, SOCIAL_EXP)
)
data <- na.omit(data)
# 1. Ottieni tutti i nomi delle colonne
nomi_colonne <- names(data)
View(data)
# 2. Identifica la colonna ID e le colonne da ordinare (escludi l'ID)
colonna_id <- "Geopolitical.entity..reporting."
colonne_da_ordinare <- setdiff(nomi_colonne, colonna_id)
# 3. Ordina le colonne per nome (alfabeticamente)
colonne_ordinate <- sort(colonne_da_ordinare)
colonne_ordinate
# 4. Crea il nuovo ordine, mettendo l'ID per primo
nuovo_ordine <- c(colonna_id, colonne_ordinate)
# 5. Applica il nuovo ordine al dataset
data_ordinato <- data %>%
select(all_of(nuovo_ordine))
head(data_ordinato)
install.packages("dplyr") # Installa la versione più recente
rm(list = ls())
graphics.off()
data0 <- read.csv(file = "data/dataset_merged.csv", header = T)
rm(list = ls())
graphics.off()
data0 <- read.csv(file = "data/dataset_merged.csv", header = T)
library(tidyr)
library(dplyr) # Utile per la manipolazione generale
# Supponiamo che il tuo dataset si chiami 'dati_originali'
data <- data0 %>%
pivot_wider(
# La colonna che identifica le righe nel nuovo dataset
id_cols = Geopolitical.entity..reporting.,
# La colonna i cui valori (es. 2020, 2021) diventeranno i nomi delle nuove colonne
names_from = TIME_PERIOD,
# La colonna i cui valori (es. 3.4, 5.1) riempiranno le nuove colonne
values_from = c(POVERTY_RATE, SOCIAL_EXP)
)
data <- na.omit(data)
# 1. Ottieni tutti i nomi delle colonne
nomi_colonne <- names(data)
# 2. Identifica la colonna ID e le colonne da ordinare (escludi l'ID)
colonna_id <- "Geopolitical.entity..reporting."
colonne_da_ordinare <- setdiff(nomi_colonne, colonna_id)
# 3. Ordina le colonne per nome (alfabeticamente)
colonne_ordinate <- sort(colonne_da_ordinare)
# 4. Crea il nuovo ordine, mettendo l'ID per primo
nuovo_ordine <- c(colonna_id, colonne_ordinate)
# 5. Applica il nuovo ordine al dataset
data_ordinato <- data %>%
select(all_of(nuovo_ordine))
View(data_ordinato)
head(data_ordinato)
View(data_ordinato)
data <- data_ordinato[-1, ]
data <- t(data)
# Visualizza l'inizio del nuovo dataset
head(data)
str(data)
head(data_ordinato)
data <- data_ordinato
data <- t(data)
# Visualizza l'inizio del nuovo dataset
head(data)
str(data)
data <- data[-1, ]
data <- data[1:9, ]
nr <- nrow(data)
nc <- ncol(data)
data <- matrix(as.numeric(data),
nrow = nr, ncol = nc)
data <- na.omit(data)
data <- as.matrix(data)
# matplot
par(mfrow = c(1,1))
matplot(data, type = 'l', lty = 1, lwd = 1.5,
main = 'Povrty Rate', xlab = 'year', ylab = 'Poverty rate')
#Calcolare la media di ogni colonna (misurazione media)
mean_curve <- rowMeans(data)
par(mfrow = c(1,1))
matplot(data, type = 'l', col = rgb(0.6, 0, 0.6, 0.2), lty = 1, lwd = 1.5,
main = 'Povrty Rate', xlab = 'year', ylab = 'Poverty rate')
# Sovrapporre la curva media con un colore più acceso e una linea più spessa
lines(mean_curve, col = "darkviolet", lwd = 3)
# BSPLINE -----------------------------------------------------------------
library(car)
# for lasso regression
library(glmnet)
# functional DataAna
library(fda)
norder <- 4        # spline order (4th order polynomials)
degree <- norder-1  # spline degree
nbasis <- 5   # how many basis we want
time <- 1:dim(data)[1]
basis_spline <- create.bspline.basis(rangeval=range(time),
nbasis=nbasis,
norder=norder)
#### PLOT DELLA BASE SPLINES
par(mfrow=c(1,1))
plot(basis_spline)
data.bspline <- Data2fd(y = data, argvals = time,basisobj = basis_spline)
#### PLOT APPROX SPLINES
# x11()
par(mfrow=c(1,2))
plot.fd(data.bspline, main = 'spline approx: degree=3, nbasis=20')
matplot(data,type='l', main = 'true curves'  )
#### FOURIER ####
nbasis <- 6
basis_fourier <- create.fourier.basis(rangeval=range(time),nbasis=nbasis)
#### PLOT BASE FOURIER
par(mfrow=c(1,1))
plot(basis_fourier)
data.fourier <- Data2fd(y = as.matrix(data),argvals = time,basisobj = basis_fourier)
#### PLOT APROX FOURIER
# x11()
par(mfrow=c(1,2))
plot.fd(data.fourier, main = 'fourier approx: nbasis=10')
matplot(data,type='l', main = 'true curves'  )
norder <- 4        # spline order (4th order polynomials)
degree <- norder-1  # spline degree
nbasis <- 6   # how many basis we want
time <- 1:dim(data)[1]
basis_spline <- create.bspline.basis(rangeval=range(time),
nbasis=nbasis,
norder=norder)
#### PLOT DELLA BASE SPLINES
par(mfrow=c(1,1))
plot(basis_spline)
data.bspline <- Data2fd(y = data, argvals = time,basisobj = basis_spline)
#### PLOT APPROX SPLINES
# x11()
par(mfrow=c(1,2))
plot.fd(data.bspline, main = 'spline approx: degree=3, nbasis=20')
matplot(data,type='l', main = 'true curves'  )
View(data)
View(data0)
# matplot
par(mfrow = c(1,1))
matplot(data, type = 'l', lty = 1, lwd = 1.5,
main = 'Povrty Rate', xlab = 'year', ylab = 'Poverty rate')
#Calcolare la media di ogni colonna (misurazione media)
mean_curve <- rowMeans(data)
par(mfrow = c(1,1))
matplot(data, type = 'l', col = rgb(0.6, 0, 0.6, 0.2), lty = 1, lwd = 1.5,
main = 'Povrty Rate', xlab = 'year', ylab = 'Poverty rate')
# Sovrapporre la curva media con un colore più acceso e una linea più spessa
lines(mean_curve, col = "darkviolet", lwd = 3)
rm(list = ls())
graphics.off()
# Data cleaning - poverty_rate
poverty_rate = read.csv(file = "data/povertyRate.csv", header = T)
poverty_rate = poverty_rate[,-(1:14)]
poverty_rate = poverty_rate[1:4]
poverty_rate = poverty_rate[,-3]
poverty_rate = poverty_rate[poverty_rate$Geopolitical.entity..reporting. != "Euro area – 20 countries (from 2023)",]
poverty_rate = poverty_rate[poverty_rate$Geopolitical.entity..reporting. != "Euro area - 19 countries  (2015-2022)",]
poverty_rate = poverty_rate[poverty_rate$Geopolitical.entity..reporting. != "European Union - 27 countries (2007-2013)",]
poverty_rate = poverty_rate[poverty_rate$Geopolitical.entity..reporting. != "European Union - 27 countries (from 2020)",]
poverty_rate = poverty_rate[poverty_rate$Geopolitical.entity..reporting. != "European Union - 28 countries (2013-2020)",]
# Data cleaning - poverty_rate
spr_expenditures = read.csv("data/spr_exp_ftm__custom_18697146_linear.csv", header = T)
spr_expenditures = spr_expenditures[spr_expenditures$geo != "Euro area – 20 countries (from 2023)",]
spr_expenditures = spr_expenditures[spr_expenditures$geo != "Euro area - 19 countries  (2015-2022)",]
spr_expenditures = spr_expenditures[spr_expenditures$geo != "European Union - 27 countries (2007-2013)",]
spr_expenditures = spr_expenditures[spr_expenditures$geo != "European Union - 27 countries (from 2020)",]
spr_expenditures = spr_expenditures[spr_expenditures$geo != "European Union - 28 countries (2013-2020)",]
spr_expenditures = spr_expenditures[spr_expenditures$geo != "Euro area - 12 countries (2001-2006)",]
spr_expenditures = spr_expenditures[spr_expenditures$geo != "Euro area - 18 countries (2014)",]
spr_expenditures = spr_expenditures[spr_expenditures$geo != "European Economic Area except Liechtenstein",]
spr_expenditures = spr_expenditures[spr_expenditures$geo != "European Free Trade Association except Liechtenstein",]
spr_expenditures = spr_expenditures[spr_expenditures$geo != "European Union - 15 countries (1995-2004)",]
View(poverty_rate)
# Data exploration
head(poverty_rate)
dim(poverty_rate)
table(poverty_rate$Geopolitical.entity..reporting.)
summary(poverty_rate)
nCountries = length(unique(poverty_rate$Geopolitical.entity..reporting.))
head(spr_expenditures)
dim(spr_expenditures)
table(spr_expenditures$geo)
summary(spr_expenditures)
View(poverty_rate)
# install.packages("ggplot2")
# install.packages("viridis") # Per la palette
library(ggplot2)
library(viridis)
paese <- poverty_rate$Geopolitical.entity..reporting.
ggplot(data = poverty_rate,
aes(x = TIME_PERIOD, y = OBS_VALUE, color = paese, group = paese)) +
geom_line(linewidth = 1.5) +  # <- Linee Grosse (linewidth > 1)
scale_color_viridis(discrete = TRUE, option = "D") + # <- Palette Variata
geom_point(size = 3) + # Punti più grandi per abbinare le linee
labs(
title = "Tasso di Povertà per Paese nel Tempo",
x = "Periodo di Tempo",
y = "Tasso di Povertà"
)
library(dplyr)
# Definisci i paesi da includere
paesi_selezionati <- c("France", "Italy", "Germany", "Bulgaria", "Poland")
data_subsample <- poverty_rate %>%
# PASSO 1: Filtra il dataframe
filter( poverty_rate$Geopolitical.entity..reporting. %in% paesi_selezionati)
paese <- data_subsample$Geopolitical.entity..reporting.
# PASSO 2: Crea il grafico con i dati filtrati
ggplot( data = data_subsample,
aes(x = TIME_PERIOD, y = OBS_VALUE, color = paese, group = paese)) +
geom_line(linewidth = 1.5) + # Linee grosse
geom_point(size = 3) +
scale_color_viridis(discrete = TRUE, option = "D") +
labs(
title = "Tassi di Povertà:",
x = "Periodo di Tempo",
y = "Tasso di Povertà"
)
# Data cleaning ----------------------------------------------------------------
data_expediture_0 = read.csv(file = "data/spr_exp_type$defaultview_linear_2_0.csv", header = T)
head(data_expediture_0)
dim(data_expediture_0)
#View(data_expediture_0)
#selection of rows of Social protection benefits
unique(data_expediture_0$Main.expenditure.type)
data_expediture_0 <- data_expediture_0[data_expediture_0$Main.expenditure.type == "Social protection benefits", ]
unique(data_expediture_0$Unit.of.measure)
data_expediture_0 <- data_expediture_0[data_expediture_0$Unit.of.measure == "Euro per inhabitant (at constant 2015 prices)", ]
# column selection
data_expediture_1 <- data_expediture_0[, 11:14]
data_expediture_1 <- data_expediture_1[, -3]
data_expediture_1 = data_expediture_1[data_expediture_1$Geopolitical.entity..reporting. != "Euro area – 20 countries (from 2023)",]
data_expediture_1 = data_expediture_1[data_expediture_1$Geopolitical.entity..reporting. != "Euro area - 19 countries  (2015-2022)",]
data_expediture_1 = data_expediture_1[data_expediture_1$Geopolitical.entity..reporting. != "European Union - 27 countries (2007-2013)",]
data_expediture_1 = data_expediture_1[data_expediture_1$Geopolitical.entity..reporting. != "European Union - 27 countries (from 2020)",]
data_expediture_1 = data_expediture_1[data_expediture_1$Geopolitical.entity..reporting. != "European Union - 28 countries (2013-2020)",]
# Data exploration
head(data_expediture_1)
dim(data_expediture_1)
table(data_expediture_1$Geopolitical.entity..reporting.)
summary(data_expediture_1)
plot(data_expediture_1$TIME_PERIOD, data_expediture_1$OBS_VALUE)
# install.packages("ggplot2")
# install.packages("viridislite") # Per la palette
# install.packages("ggrepel") # per le etichette
library(ggplot2)
library(viridis)
library(dplyr)
library(ggrepel)
paese <- data_expediture_1$Geopolitical.entity..reporting.
# creo le etichette
data_labels <- data_expediture_1 %>%
group_by(Geopolitical.entity..reporting.) %>%
# Trova la riga con il TIME_PERIOD più recente per ogni paese
slice_max(order_by = TIME_PERIOD, n = 1) %>%
ungroup()
#grafico con legenda
ggplot(data = data_expediture_1,
aes(x = TIME_PERIOD, y = OBS_VALUE, color = paese, group = paese)) +
geom_line(linewidth = 1.5) +  # <- Linee Grosse (linewidth > 1)
scale_color_viridis(discrete = TRUE, option = "D") + # <- Palette Variata
geom_point(size = 3) + # Punti più grandi per abbinare le linee
labs(
title = "Social Protection Benefits per Paese nel Tempo",
x = "Periodo di Tempo",
y = "Social Protection Benefits"
)
#grafico con le etichette
ggplot(data = data_expediture_1,
aes(x = TIME_PERIOD, y = OBS_VALUE, color = Geopolitical.entity..reporting., group = Geopolitical.entity..reporting.)) +
geom_line(linewidth = 1.5) +
scale_color_viridis(discrete = TRUE, option = "D") +
geom_point(size = 3) +
# --- INIZIO MODIFICHE ---
# 1. Aggiungi le etichette "intelligenti" alla fine delle linee
geom_text_repel(
data = data_labels, # Usa i dati che abbiamo filtrato
aes(label = Geopolitical.entity..reporting.), # L'etichetta è il nome del paese
size = 3.5,
fontface = "bold",
nudge_x = 0.2,       # Sposta le etichette leggermente a destra
direction = "y",     # Permetti di spostarle solo in verticale
hjust = 0,           # Allinea il testo a sinistra
segment.color = "grey50" # Colore della lineetta di collegamento
) +
# 2. Fai spazio a destra per le etichette
# Aumenta l'espansione del 15% sul lato destro (mult = c(0.05, 0.15))
scale_x_continuous(expand = expansion(mult = c(0.05, 0.15))) +
# 3. Rimuovi la legenda
theme(legend.position = "none") +
# --- FINE MODIFICHE ---
labs(
title = "Social Protection Benefits per Paese nel Tempo",
x = "Periodo di Tempo",
y = "Social Protection Benefits"
)
# Definisci i paesi da includere
paesi_selezionati <- c("France", "Italy", "Germany", "Bulgaria", "Poland")
data_subsample <- data_expediture_1 %>%
# PASSO 1: Filtra il dataframe
filter( data_expediture_1$Geopolitical.entity..reporting. %in% paesi_selezionati)
paese <- data_subsample$Geopolitical.entity..reporting.
# creo le etichette
data_labels_selezionati <- data_subsample %>%
group_by(Geopolitical.entity..reporting.) %>%
# Trova la riga con il TIME_PERIOD più recente per ogni paese
slice_max(order_by = TIME_PERIOD, n = 1) %>%
ungroup()
#plot
ggplot( data = data_subsample,
aes(x = TIME_PERIOD, y = OBS_VALUE, color = Geopolitical.entity..reporting., group = Geopolitical.entity..reporting.)) +
geom_line(linewidth = 1.5) + # Linee grosse
geom_point(size = 3) +
scale_color_viridis(discrete = TRUE, option = "D") +
# --- INIZIO MODIFICHE ---
# 1. Aggiungi le etichette "intelligenti" alla fine delle linee
geom_text_repel(
data = data_labels_selezionati, # Usa i dati che abbiamo filtrato
aes(label = Geopolitical.entity..reporting.), # L'etichetta è il nome del paese
size = 3.5,
fontface = "bold",
nudge_x = 0.2,       # Sposta le etichette leggermente a destra
direction = "y",     # Permetti di spostarle solo in verticale
hjust = 0,           # Allinea il testo a sinistra
segment.color = "grey50" # Colore della lineetta di collegamento
) +
# 2. Fai spazio a destra per le etichette
# Aumenta l'espansione del 15% sul lato destro (mult = c(0.05, 0.15))
scale_x_continuous(expand = expansion(mult = c(0.05, 0.15))) +
# 3. Rimuovi la legenda
theme(legend.position = "none") +
# --- FINE MODIFICHE ---
labs(
title = "Social Protection Benefits:",
x = "Periodo di Tempo",
y = "Social Protection Benefits"
)
library(dplyr)
# Trova la colonna con il vecchio nome e assegnale il nuovo nome
names(data_expediture_1)[names(data_expediture_1) == "OBS_VALUE"] <- "SOCIAL_EXP"
poverty_rate <- read.csv(file = "data/poverty_rate_cleaned.csv", header = T)
names(poverty_rate)[names(poverty_rate) == "OBS_VALUE"] <- "POVERTY_RATE"
# Il dataset 'dati' viene modificato direttamente in questo caso
dataset_merged <- left_join(
x = data_expediture_1,      # Il dataset principale (left/sinistro)
y = poverty_rate,  # Il dataset da cui prendere le nuove colonne (right/destro)
# Specifica le colonne (chiavi) su cui basare l'unione
by = c("Geopolitical.entity..reporting.", "TIME_PERIOD")
)
head(dataset_merged)
